############################
Paths, files and directories
############################

`xal` provides an interface to browse directories and manage files.


******
fs API
******

FileSystem resource
===================

.. autoclass:: xal.fs.resource.FileSystem

.. doctest::

   >>> from xal.fs.resource import FileSystem
   >>> def demo_resource(session):
   ...     """Demonstrate use of ``FileSystem`` resource."""
   ...     fs = session.fs  # Just a shortcut.
   ...
   ...     # ``session.fs`` is a resource factory.
   ...     resource = fs('test-fs')
   ...     assert isinstance(resource, FileSystem)
   ...
   ...     # Just use path as strings.
   ...     assert str(resource) == 'test-fs'
   ...
   ...     # Paths remain relative until they are actually used. Absolute
   ...     # values are used as soon as filesystem operation is performed.
   ...     assert resource.is_relative()
   ...     created_resource = resource.mkdir()
   ...     assert created_resource.is_absolute()
   ...     assert resource.is_relative()  # Original value is preserved.
   ...
   ...     # Cleanup.
   ...     fs.rm(created_resource)

cd
==

.. automethod:: xal.fs.resource.FileSystem.cd

.. doctest::

   >>> def demo_cd(session):
   ...     """Demonstrate use of ``cd``."""
   ... 	   fs = session.fs  # Just a shortcut.
   ...
   ...     # Let's create a new directory.
   ...     path = fs.mkdir('test-fs')
   ...
   ...     # Change working directory.
   ...     initial_path = fs.cwd()
   ...     assert fs.cwd() != path
   ...     with fs.cd(path) as sub_path:
   ...         assert fs.cwd() == path == sub_path
   ...         assert sub_path.parent == initial_path
   ...     assert fs.cwd() == initial_path
   ...
   ...     # Also works without context manager.
   ...     # Notice that once used, paths are absolute.
   ...     rel_path = fs('test-fs')
   ...     assert rel_path.is_relative()
   ...     abs_path = rel_path.cd()
   ...     assert abs_path.is_absolute()
   ...
   ...     # Cleanup.
   ...     fs.cd(initial_path)
   ...     fs.rm(path)

mkdir
=====

.. automethod:: xal.fs.resource.FileSystem.mkdir

.. doctest::

   >>> def demo_mkdir(session):
   ...     """Demonstrate use of ``mkdir``."""
   ...     fs = session.fs  # Just a shortcut.
   ...
   ...     # Let's create a new directory.
   ...     assert not fs.exists('test-fs')
   ...     path = fs.mkdir('test-fs')
   ...     assert fs.exists('test-fs')
   ...
   ...     # mkdir() returns absolute path, even if created from relative
   ...     # value.
   ...     assert str(path) != 'test-fs'
   ...     assert path.is_absolute()
   ...
   ...     # Cleanup.
   ...     fs.rm(path)


*********
Providers
*********

Local
=====

Let's execute demo function above in local session.

First setup a local session:

.. doctest::

   >>> from xal.session.local import LocalSession
   >>> session = LocalSession()

Then run generic code within specific session:

.. doctest::

   >>> demo_resource(session)
   >>> demo_cd(session)
   >>> demo_mkdir(session)

SSH using Fabric
================

Let's do the same over SSH using Fabric!

Setup some SSH session:

.. doctest::

   >>> from xal.session.fabric import FabricSession
   >>> session = FabricSession()
   >>> session.client.connect('localhost')
   True

Then run generic code within specific session:

.. doctest::

   >>> demo_resource(session)
   >>> demo_cd(session)
   >>> demo_mkdir(session)


****
Path
****

`xal` provides an API inspired by :mod:`pathlib`.

Properties like pathlib.PurePath
================================

``Path`` instances have properties just like pathlib's pure paths.

Let's consider an example with relative path:

.. doctest::

   >>> from xal.session.local import LocalSession
   >>> session = LocalSession()

   >>> from xal.fs.resource import Path
   >>> path = Path('resources')
   >>> path.xal_session = session
   >>> path  # doctest: +ELLIPSIS
   Path('resources')
   >>> path.drive
   ''
   >>> path.root
   ''
   >>> path.anchor
   ''
   >>> path.parents
   (Path('.'),)
   >>> path.parent
   Path('.')
   >>> path.name
   'resources'
   >>> path.suffix
   ''
   >>> path.suffixes
   []
   >>> path.stem
   'resources'

Let's consider an example with absolute path:

.. doctest::

   >>> path = Path('/home/me/resources')
   >>> path.xal_session = session
   >>> path  # doctest: +ELLIPSIS
   Path('/home/me/resources')
   >>> path.drive
   ''
   >>> path.root
   '/'
   >>> path.anchor
   '/'
   >>> path.parents
   (Path('/home/me'), Path('/home'), Path('/'))
   >>> path.parent
   Path('/home/me')
   >>> path.name
   'resources'
   >>> path.suffix
   ''
   >>> path.suffixes
   []
   >>> path.stem
   'resources'

Methods like pathlib.PurePath
=============================

.. doctest::

   >>> path = session.path
   >>> path('resources') / path('fs.txt')
   Path('resources/fs.txt')

   >>> print unicode(path('resources'))
   resources
   >>> print unicode(path('/home/benoit/resources'))
   /home/benoit/resources

   >>> print str(path('resources'))
   resources
   >>> print str(path('/home/benoit/resources'))
   /home/benoit/resources

   >>> path('/home/benoit/resources').as_posix()
   '/home/benoit/resources'

   >>> path('/home/benoit/resources').as_uri()
   'file:///home/benoit/resources'

   >>> path('resources').is_absolute()
   False

   >>> path('nul').is_reserved()
   False

   >>> path('/home').joinpath('resources', path('fs.txt'))
   Path('/home/resources/fs.txt')

   >>> path('a/b.py').match('*.py')
   True
   >>> path('/a/b/c.py').match('b/*.py')
   True
   >>> path('/a/b/c.py').match('a/*.py')
   False

   >>> p = path('/etc/passwd')
   >>> p.relative_to('/')
   Path('etc/passwd')
   >>> p.relative_to('/etc')
   Path('passwd')
   >>> p.relative_to('/usr')  # doctest: +ELLIPSIS
   Traceback (most recent call last):
     ...
   ValueError: '/etc/passwd' does not start with '/usr'

   >>> p = path('/Downloads/pathlib.tar.gz')
   >>> p.with_name('setup.py')
   Path('/Downloads/setup.py')
   >>> p = path('/')
   >>> p.with_name('setup.py')  # doctest: +ELLIPSIS
   Traceback (most recent call last):
     ...
   ValueError: Path('/') has an empty name

   >>> p = path('/Downloads/pathlib.tar.gz')
   >>> p.with_suffix('.bz2')
   Path('/Downloads/pathlib.tar.bz2')
   >>> p = path('README')
   >>> p.with_suffix('.txt')
   Path('README.txt')

Methods like pathlib.Path
=========================

stat()

.. doctest::

   >>> p = path('conf.py')
   >>> p.stat().st_size
   4172
   >>> p.stat().st_mode
   33188

chmod(mode)

.. doctest::

   >>> p = path('conf.py')
   >>> p.stat().st_mode
   33188
   >>> p.chmod(0o444)
   >>> p.stat().st_mode
   33060
   >>> p.chmod(0o644)

exists()

.. doctest::

   >>> path('.').exists()
   True
   >>> path('conf.py').exists()
   True
   >>> path('/etc').exists()
   True
   >>> path('nonexistentfile').exists()
   False

glob(pattern) and rglob(pattern)

.. doctest::

   >>> sorted(path('.').glob('*.txt'))
   [Path('contributing.txt'), Path('index.txt'), Path('install.txt')]
   >>> sorted(path('.').glob('*/fs.txt'))
   [Path('resources/fs.txt')]

   >>> sorted(path().rglob('*.txt'))  # doctest: +NORMALIZE_WHITESPACE
   [Path('about/alternatives.txt'),
    Path('about/authors.txt'),
    Path('about/changelog.txt'),
    Path('about/index.txt'),
    Path('about/license.txt'),
    Path('about/vision.txt'),
    Path('contributing.txt'),
    Path('index.txt'),
    Path('install.txt'),
    Path('presentations/2013-europython/index.txt'),
    Path('presentations/index.txt'),
    Path('presentations/xal.txt'),
    Path('resources/fs.txt'),
    Path('resources/index.txt'),
    Path('resources/sh.txt')]

group()

.. doctest::

   >>> path('.').group()
   'benoit'

is_dir()

.. doctest::

   >>> path('resources').is_dir()
   True
   >>> path('index.txt').is_dir()
   False

is_file()

.. doctest::

   >>> path('index.txt').is_file()
   True
   >>> path('resources').is_file()
   False

is_symlink() and symlink_to(target, target_is_directory=False)

.. doctest::

   >>> path('index.txt').is_symlink()
   False
   >>> path('test-symlink').exists()
   False
   >>> path('test-symlink').is_symlink()
   False
   >>> path('test-symlink').symlink_to(path('index.txt'))
   >>> path('test-symlink').is_symlink()
   True
   >>> path('test-symlink').unlink()

is_socket()

.. doctest::

   >>> path('index.txt').is_socket()
   False
   >>> path('non-existent-file').is_socket()
   False

is_fifo()

.. doctest::

   >>> path('index.txt').is_fifo()
   False
   >>> path('non-existent-file').is_fifo()
   False

is_block_device()

.. doctest::

   >>> path('index.txt').is_block_device()
   False
   >>> path('non-existent-file').is_block_device()
   False
   >>> path('/dev/sda').is_block_device()
   True

is_char_device()

.. doctest::

   >>> path('index.txt').is_char_device()
   False
   >>> path('non-existent-file').is_char_device()
   False
   >>> path('/dev/tty').is_char_device()
   True

iterdir()

.. doctest::

   >>> items = [child for child in path('about').iterdir()]
   >>> sorted(items)  # doctest: +NORMALIZE_WHITESPACE
   [Path('about/alternatives.txt'),
    Path('about/authors.txt'),
    Path('about/changelog.txt'),
    Path('about/index.txt'),
    Path('about/license.txt'),
    Path('about/vision.txt')]

lchmod()

lstat()

mkdir(mode=0o777, parents=False) and rmdir()

.. doctest::

   >>> import stat
   >>> resource = path('dummy')
   >>> assert not resource.exists()
   >>> try:
   ...     resource = resource.mkdir(mode=0o644)
   ...     assert resource.exists()
   ...     assert stat.S_IMODE(resource.stat().st_mode) == 0o644
   ... finally:
   ...     resource.rmdir()
   >>> assert not resource.exists()

open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)

.. doctest::

   >>> print path('../VERSION').open().read()
   0.2.dev0
   <BLANKLINE>
   >>> with path('../VERSION').open() as resource:
   ...     print resource.read()
   0.2.dev0
   <BLANKLINE>

owner()

.. doctest::

   >>> print path('.').owner()
   benoit

rename() and replace()

.. doctest::

   >>> p = path('foo')
   >>> p.open('w').write(u'some text')
   9L
   >>> target = path('bar')
   >>> p.exists()
   True
   >>> target.exists()
   False
   >>> p.rename(target)
   >>> path('foo').exists()
   False
   >>> path('bar').exists()
   True
   >>> target.open().read()
   u'some text'
   >>> p.name
   'bar'

   >>> path('replaced').open('w').write(u'another text')
   12L
   >>> p.replace('replaced')
   >>> path('replaced').open().read()
   u'some text'
   >>> path('bar').exists()
   False

   >>> path('replaced').unlink()  # Cleanup.

resolve()

.. doctest::

   >>> print path().resolve()
   /mnt/data/web/xal/docs

touch(mode=0o777, exist_ok=True) and unlink()

.. doctest::

   >>> path('foo').exists()
   False
   >>> p = path('foo').touch(mode=0o644)
   >>> p.exists()
   True
   >>> p.is_file()
   True
   >>> stat.S_IMODE(p.stat().st_mode) == 0o644
   True
   >>> p.touch()
   Path('foo')

   >>> p.unlink()
   >>> p.exists()
   False


Differences with pathlib
========================

cwd()
-----

:mod:`pathlib` implements ``cwd()`` as a class-level method of ``Path``. In
`xal`, it is a method of the instance of provider API, generally
``session.fs.cwd()``.

mkdir() as a context manager
----------------------------

with mkdir() block destroys created tree on exit. # TODO

resolve() works with non-existent files
---------------------------------------

pathlib.Path.resolve() raises OSError when called on a non-existent file or
directory. In case of non existent file, `xal`'s resolve() returns absolute
path to file.

touch() returns Path instance
-----------------------------

pathlib.Path.touch() returns None, whereas xal's Path.touch() returns Path
instance, so that calls can be chained.
